package com.sist.main;
// 문법
/*
 *    변수 (데이터형) = 연산자 = 제어문 = 배열 = 메소드 = 클래스
 *    클래스 : 캡슐화 / 상속, 포함 / 오버로딩, 오버라이딩 (다형성)
 *           =====
 *           접근 지정어 : private < default < protected < public
 *           프로그램
 *             = 변수 : 은닉화 (private)
 *             = 메소드 : 다른 클래스와 연결 (public)
 *             = 생성자 : 클래스를 저장하기 위해 사용 (new 생성자()) => 초기화(멤버변수) public
 *             = 클래스 : (public, default)
 *             = 객체 (부품) => 연결해서 사용 (조립)
 *             ====================================================================
 *             변수사용
 *             ======
 *               = 멤버변수 : private 데이터형 변수명
 *               = 공유변수 : ==> private static 데이터형 변수명;
 *               = 지역변수 (메소드에서만 사용) : 사용할 수 있는 제어자 => final (상수)
 *               변수 => 읽기 (메모리에 값을 가지고 온다), 쓰기 (메모리에 값 저장)
 *                      private => 다른 클래스에서 연결할 수 없다
 *                                 연결을 위해 =>
 *               
 *                
 *                
 *                
 *                
 *                => 변수 반드시 초기화
 *                   => 멤버변수 (클래스 영역에 설정 : 자동 초기화)
 *                      1) 초기화 블록 {}
 *                      2) 생성자
 *                   => 지역변수는 초기화를 프로그래머가 설정 (반드시 설정)
 *                   => 직접 대입, 사용자의 입력값을 받아서 처리, 파일 읽기, 데이터베이스
 *                      =======  ===========================================
 *                        선언            구현 ==> 구현은 반드시 {}안에서 설정
 *             메소드 : 용도 => 다른 클래스와 연결(통신) => 한가지 기능만 수행이 가능 (재사용)
 *                    새로운 메소드 제작 (오버로딩)
 *                    기존에 있는 메소드 변경 (오버라이딩)
 *             ================================================================
 *             				  	  오버로딩					오버라이딩
 *             ================================================================
 *              메소드명              o (동일)                    o
 *             ================================================================
 *              리턴형                x                         o
 *             ================================================================
 *              매개변수          x (갯수, 데이터형 다름)            o
 *             ================================================================
 *                                                      접근지정어가 확장이 가능
 *                                 private < default < protected < public 
 *              private : 자신의 클래스에서만 사용이 가능
 *              default : 자신의 클래스 + 같은 패키지안에서 접근이 가능
 *              protected : 자신의 클래스, 같은 패키지 + 다른 패키지 => 상속을 받은 클래스
 *              public : 모든 클래스 (패키지와 상관이 없다)
 *             ================================================================
 *             클래스의 종류
 *             ===========
 *             1. 일반 클래스 (스프링 : POJO) => 독립적인 클래스)
 *                public class ClassName
 *                {
 *                  ====================
 *                   멤버변수
 *                     = 인스턴스 변수
 *                     = 공유 변수
 *                  ====================
 *                   생성자
 *                     오버로딩이 가능 => 여러개 제작 가능
 *                     없는 경우도 있다 => 컴파일러가 자동으로 생성 (디폴트 생성자)
 *                  ====================
 *                   메소드 : 여러개, 한개... => 기능 설정
 *                  ====================
 *                }
 *                
 *             2. 몸통이 없는 클래스 (메소드가 구현이 안된 미완성된 클래스) => 설계 (프로그래머가 구현해서 사용)
 *                ============== 자신의 클래스로 메모리에 저장 할 수 없다 (구현된 하위클래스를 이용해서 메모리 할당)
 *                  = 서로 다른 클래스를 연결해서 사용 (여러개를 모아서 한개의 이름을 제어)
 *                  = 개, 돼지, 소, 말, 인간 => 동물 (추상클래스)
 *                  = 변수여러개 => 배열이름(한개)으로 제어
 *                  = 비슷한 클래스 => 추상클래스, 인터페이스로 제어 (한개만 생성)
 *                = 추상클래스
 *                  public abstract class ClassName
 *                  {
 *                     =========================
 *                      멤버변수
 *                        = 인스턴스 변수
 *                        = 공유 변수
 *                     =========================
 *                      생성자
 *                     =========================
 *                      메소드
 *                        = 구현이 안된 메소드 (추상메소드)
 *                          public abstract 리턴형 (매개변수...);
 *                          => 상속을 받은 경우에 반드시 구현해서 사용
 *                        = 구현이 된 메소드
 *                          public 리턴형 메소드 (매개변수...)
 *                          {
 *                          }
 *                          => 필요하면 오버라이딩해서 사용, 있는 그대로 사용이 가능
 *                          메소드는 {} 블록만 있어도 구현이 된다
 *                     =========================
 *                  }
 *                = 인터페이스 (웹에서 가장 많이 사용) => 스프링의 기본 연결
 *                  =========================== 결합성을 낮게 만든다
 *                  ==> 추상클래스의 일종 (메소드가 거의 => 추상메소드, 변수는 상수형 변수)
 *                  public interface Interface명
 *                  {
 *                    ==========================
 *                     변수 : 반드시 값을 지정해서 사용 => 상수형
 *                     (public static final) int a=10;
 *                    ==========================
 *                             생략
 *                    ==========================
 *                     메소드
 *                     (public abstract) 리턴형 메소드 (매개변수);
 *                     =======
 *                     모든 메소드는 public
 *                    ==========================
 *                    jdk1.8 설정
 *                    ==========================
 *                     구현이 가능한 메소드가 추가
 *                     default메소드, static메소드
 *                     public default 리턴형 메소드(매개변수)
 *                     {
 *                     }
 *                     public static 리턴형 메소드(매개변수)
 *                     {
 *                     }
 *                    ==========================
 *                    
 *                  }
*             3. 내부클래스 : 윈도우, 네트워크, 쓰레드(앱 => 카카오) : 서버 직접 제작...
*               = 멤버 클래스 : 변수나 메소드를 두개 이상의 클래스에서 쉽게 접근이 가능하게 제작
*                 public class ClassName
*                 {
*                     ==================
*                      멤버변수
*                     ==================
*                      메소드
*                     ==================
*                      class ClassName(쓰레드)
*                      {
*                         여기서 => 위에 있는 멤버변수, 메소드를 자유롭게 사용이 가능
*                      }
*                     ==================
*                 }
*                 =======> 분석 (MapReduce) => 데이터분석 (코모란, 꼬꼬마...)
*                 
 *             = 익명의 클래스 : 상속이 없이 오버라이딩이 가능하게 만드는 클래스
 *               class A
 *               {
 *                  public void display() {}
 *               }
 *               
 *               class B extends A
 *               {
 *                  public void display() {}를 재정의 => 오버라이딩
 *               }
 *               -------------------------------------------------
 *               class A
 *               {
 *                  public void display() {}
 *               }
 *               class B
 *               {
 *                  A a=new A()
 *                  {
 *                      public void display() // 오버라이딩
 *                  }
 *               }
 *        ================================================
 *        문제 => 오류 (에러)
 *            => 오류를 방지하는 프로그램 => 예외처리 (조건문으로 사용)
 *            => 에러) 프로그램이 실행될 경우 => 비정상 종료, 멈춤상태
 *            ==============================================
 *            시스템 에러, 프로그램상에서 에러 (사용자가 입력을 잘못한 경우, 프로그래머 실수)
 *            =========  ====================================================
 *            처리할 수 있는 에러가 아니다            처리가 가능한 에러
 *            ======================            ==============
 *                  에러 (Error)                     예외처리 (수정이 가능한 에러) Exception
 *            예) 메모리가 부족하다                    예) 사용자가 정수입력 => 문자열
 *               윈도우가 멈춤                           배열의 인덱스 초과
 *               서버가 속도가 늦어서 접근이 불가능          소스상에서 수정이 가능 (서버주소가 틀리다,
 *               웹크롤링 => 접근 거부                   파일명을 잘못 사용...
 *                                                   SQL(오라클) 문장이 틀리다
 *            ==> 예외처리 (사전에 오류를 방지하는 프로그램) => 비정상종료를 방지하고 정상상태를 유지
 *                ======
 *                1) 예외가 났을 경우 => 복구 => try ~ catch (점프를 해서 정상 상태로 이동)
 *                                          ====  ======> 복구하는 위치
 *                                          정상수행이 가능
 *                                          => catch를 사용해서 복구 (소스가 변경이 된 것이 아니라)
 *                                             단지 => 점프를 해서 다음의 문장을 수행
 *                   try 
 *                   {
 *                      int a=10; => 정상수행
 *                      int b=0; => 정상수행
 *                      int c=a/b; => 0으로 나눠서 오류 발생 ==> catch로 이동 (점프)
 *                      System.out.println(c); => 수행하지 않는다
 *                   }catch()
 *                   {
 *                      복구처리 => 다음 or 처음으로 수행
 *                   }
 *                   System.out.println("프로그램 종료!");
 *                ------------------------------------------------------------                
 *                2) 예외가 났을 경우 => 회피
 *                   메소드() throws ..... => 시스템에서 처리 (알려만 준다)
 *                   
 *          예외처리와 관련된 클래스
 *           = Check Exception : 컴파일시 (javac) ==> 예외처리를 하지 않으면 컴파일시 에러가 발생
 *                               document doc=Jsoup.connection(URL).get();
 *           = UnCheck Exception : 실행시 (java) ===> 생략이 가능
 *           예외처리 구조(상속도) : 예외처리도 순서가 있다
 *                  Object : 모든 자바 클래스의 최상위
 *                     |
 *                  Throwsable   
 *                     |
 *               ===================================
 *               |                                 |
 *             Error                           Exception
 *               |                                 |
 *         OutOfMemoryError                 =========================
 *      메모리를 더 이상 사용할 수 없다           |(uncheck)               |(check Exception)
 *                                    RuntimeException
 *                                         | 생략이 가능한 에러
 *                                 ArrayIndexOutOfBoundsException
 *                                   => 배열의 인덱스 초과
 *                                   int[] arr=new int[2];
 *                                   int[0]=10;
 *                                   int[2]=20; => Error 배열 초과
 *                                 ArithmeticException
 *                                   => 0으로 나눈 경우
 *                                   int a=10/0; => 
 *                                 NumberFormatException
 *                                   String s="10";
 *                                   => 정수형 변환이 안된다
 *                                   Integer.parseInt(s); ==> 웹에서는 데이터 전송시
 *                                                            문자열
 *                                                            1 ==> (X)
 *                                                            "1" ==> (O)
 *                                 ClassCastException
 *                                   => class A
 *                                   => class B
 *                                      A a=new A();
 *                                      B b=new B();
 *                                      
 *                                      b=(B)a; => CastException
 *                                      관련이 없는 클래스는 형변환을 할 수 없다
 *                                      ==============
 *                                        1. 상속  2. 포함 ==> 형변환이 가능
 *                                        
 *                                 NullPointerException
 *                                   => class A
 *                                      {
 *                                          public void display()
 *                                          {
 *                                          }
 *                                      }
 *                                      
 *                                      A a; ==> NullPointerException
 *                                      === a는 참조변수 => 주소가 없는 경우
 *                                      클래스, 배열은 여러개를 동시에 제어 => 메모리 주소를 여러개 가지고 있음
 *                                      a.display();
 *                                 ==================================================
 *                                 Check Exception => 반드시 예외 처리를 한다
 *                                 ================ 컴파일러가 예외처리를 했는지 여부 확인
 *                                                  (없는 경우에 바로 에러를 출력)
 *                                 1) IOException : 파일 입출력
 *                                                  ========= (파일 경로명..)
 *                                 2) MalformedURLException : URL주소 (네트워크)
 *                                                   URL주소가 틀리거나, 서버주소가 틀릴경우
 *                                 3) SQLException : SQL문장 틀린경우 (오라클 연동)
 *                                 4) InterruptedException : 쓰레드 충돌을 방지할 때 사용
 *                                     => 데틀락, 스타베이션 (기술면접) 
 *                                        => 쓰레드 (동기화, 비동기화)
 *                                                 =====
 *                                                 한 개의 쓰레드가 작업을 종료 후
 *                                                 다음 쓰레드가 동작 (쓰레드 작업하는 과정에서
 *                                                                 멈추는 상태)
 *                                 5) ClassNotFoundException : 스프링
 *      예외처리 방법 : 조건문으로 가능 여부 확인 => 조건문으로 해결 할 수 없는 예외 (예외처리)
 *      = 예외 복구 (프로그래머가 처리) => 중간에 프로그램을 종료하지 않는 프로그램을 만들 경우 사용)
 *        => 예외 직접 처리
 *           try ~ catch ~ finally (주로 공부)
 *      = 예외 회피 (시스템에 알려주는 방법)                           
 *        => 예외 간접 처리
 *           throws (주로 공부)
 *      = 예외 전환
 *        => 임의로 발생 (에러를 일부로 발생 => 프로그램이 견고한지 확인할 때) : 배포 => (게임) 테스터들이 주로 사용
 *           throw
 *      = 지원하지 않는 예외 : 사용자 정의 (예외처리를 제작할 수 있다) => if문
 *                              
 *      1) 직접 처리 형식 (try ~ catch)
 *         try
 *         {
 *             평상시 만드는 모든 소스코드 (정상적으로 수행 가능한 부분)
 *             => 에러가 발생 할 수도 있다
 *         }catch (예외처리의 종류)
 *         {
 *             => 에러가 발생했을 경우 => 복구할 수 있는 소스코딩을 만든다
 *         }
 *         finally
 *         {
 *             => 생략이 가능
 *             => 서버 종료, 파일 닫기, 데이터베이스 종료
 *             => try, catch와 관련이 없이 무조건 수행이 가능한 문장
 *         }
 *         
 *         => 프로그램 전체를 예외처리 할 수도 있다
 *         => 부분적으로 처리도 가능 하다 (발생 가능한 위치에서 예외처리 가능)
 *         try
 *         {
 *            1문장
 *            2문장
 *            3문장
 *            4문장
 *            5문장
 *         }
 *         catch()
 *         {
 *            예외처리문장
 *         }
 *         -------------------------
 *         1문장
 *         2문장
 *         try
 *         {
 *            3문장  
 *            4문장
 *         }
 *         catch()
 *         {
 *            오류처리문장
 *         }
 *         5문장
 *         
 *         =========================
 *         try
 *         {
 *            for(int i=0; i<=10; i++)
 *            {
 *                실행문장
 *                => i==5에서 에러 발생 ==> catch로 이동 ==> 0,1,2,3,4 => 처리
 *            }
 *         }catch()
 *         {
 *         }
 *         
 *         
 *         for(int i=0; i<=10; i++)
 *         {
 *            try
 *            {
 *                실행문장
 *                => i==5일 때 에러 발생 ==> catch로 이동 ====> 0,1,2,3,4,   6,7,8,9,10
 *            }catch()
 *            {
 *                에러처리문장 ==> 증가식으로 이동
 *            }
 *         }
 *        
 *         
 */
public class MainClass {

	public static void main(String[] args) {
		/*
		try
		{
			for(int i=0; i<=10; i++) {
				if(i==5) {
					System.out.println(i/0);
				}
				System.out.println("i="+i);
			}
		}catch(Exception e)
		{
			System.out.println(e.getMessage());
		}
		System.out.println("프로그램 종료!!");
		*/
		for(int i=1; i<=10; i++) {
			try
			{
				if(i==5) {
					System.out.println(i/0);
				}
				System.out.println("i="+i);
			}catch(Exception ex) {
				System.out.println(ex.getMessage()); // for의 증가식으로 이동 i++
			}
		}
		System.out.println("프로그램 종료!!");
	}

}
